<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - materials - shaders [custom]</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script id="vertexShader" type="x-shader/x-vertex">

      varying vec2 vUv;

      void main()
      {
      	vUv = uv;
      	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      	gl_Position = projectionMatrix * mvPosition;
      }
    </script>
    <script id="fragment_shader4" type="x-shader/x-fragment">

      uniform float time;

      varying vec2 vUv;

      void main( void ) {

      	vec2 position = - 1.0 + 2.0 * vUv;

      	float red = abs( sin( position.x * position.y + time / 5.0 ) );
      	float green = abs( sin( position.x * position.y + time / 4.0 ) );
      	float blue = abs( sin( position.x * position.y + time / 3.0 ) );
      	gl_FragColor = vec4( red, green, blue, 1.0 );

      }
    </script>

    <script src="/node_modules/three/build/three.js"></script>
    <script src="/js/stats.min.js"></script>
    <script type="module">
      let stats;
      let camera, scene, renderer, clock;
      let uniforms1;
      init();
      animate();

      function init() {
        const container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          1,
          3000
        );
        camera.position.z = 100;

        scene = new THREE.Scene({ antialias: true });

        clock = new THREE.Clock();

        const geometry = new THREE.BoxBufferGeometry(20, 20, 20);

        uniforms1 = {
          time: { value: 1.0 },
        };

        const params = [["fragment_shader4", uniforms1]];

        for (let i = 0; i < params.length; i++) {
          const material = new THREE.ShaderMaterial({
            uniforms: params[i][1],
            vertexShader: document.getElementById("vertexShader").textContent,
            fragmentShader: document.getElementById(params[i][0]).textContent,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.x = i - (params.length - 1) / 2;
          mesh.position.y = (i % 2) - 0.5;
          scene.add(mesh);
        }

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        stats = new Stats();
        container.appendChild(stats.dom);

        onWindowResize();

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      //

      function animate() {
        requestAnimationFrame(animate);

        render();
        stats.update();
      }

      function render() {
        const delta = clock.getDelta();

        uniforms1["time"].value += delta * 5;

        for (let i = 0; i < scene.children.length; i++) {
          const object = scene.children[i];

          object.rotation.y += delta * 0.5 * (i % 2 ? 1 : -1);
          object.rotation.x += delta * 0.5 * (i % 2 ? -1 : 1);
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
lll
