<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as util from "./js/util.js";
      import * as THREE from "./node_modules/three/build/three.module.js";
      import { TransformControls } from "./node_modules/three/examples/jsm/controls/TransformControls.js";
      import { Flow } from "./node_modules/three/examples/jsm/modifiers/CurveModifier.js";
      import Stats from "./js/stats.module.js";
      const ACTION_SELECT = 1,
        ACTION_NONE = 0;
      const curveHandles = [];

      let stats;
      let scene,
        camera,
        renderer,
        rayCaster,
        control,
        mouse,
        flow,
        action = ACTION_NONE;

      init();
      animate();

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(2, 2, 4);
        camera.lookAt(scene.position);

        const initialPoints = [
          { x: 1, y: 0, z: -1 },
          { x: 1, y: 0, z: 1 },
          { x: -1, y: 0, z: 1 },
          { x: -1, y: 0, z: -1 },
        ];

        const boxGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const boxMaterial = new THREE.MeshBasicMaterial(0x99ff99);
        for (const handlePos of initialPoints) {
          const handle = new THREE.Mesh(boxGeometry, boxMaterial);
          handle.position.copy(handlePos);
          curveHandles.push(handle);
          scene.add(handle);
        }

        const curve = new THREE.CatmullRomCurve3(
          curveHandles.map((handle) => handle.position)
        );
        curve.curveType = "centripetal";
        curve.closed = true;

        const points = curve.getPoints(50);
        const line = new THREE.LineLoop(
          new THREE.BufferGeometry().setFromPoints(points),
          new THREE.LineBasicMaterial({ color: 0x00ff00 })
        );

        scene.add(line);

        //

        const light = new THREE.DirectionalLight(0xffaa33);
        light.position.set(-10, 10, 10);
        light.intensity = 1.0;
        scene.add(light);

        const light2 = new THREE.AmbientLight(0x003973);
        light2.intensity = 1.0;
        scene.add(light2);

        //

        const loader = new THREE.FontLoader();
        loader.load("/font/font.json", function (font) {
          const textGeo = new THREE.TextGeometry("Hello three.js!", {
            font: font,
            size: 0.2,
            height: 0.05,
            curveSegments: 12,
            // bevelEnabled: true,f
            bevelThickness: 10,
            bevelSize: 8,
            bevelSegments: 5,
          });
          const material = new THREE.MeshPhongMaterial({
            color: 0xf01711,
            flatShading: true,
          });
          const textMesh = new THREE.Mesh(textGeo, material);
          textMesh.rotation.x = Math.PI;
          flow = new Flow(textMesh);
          flow.updateCurve(0, curve);
          scene.add(flow.object3D);
        });

        // geometry.rotateX(Math.PI);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        mouse = new THREE.Vector2();
        renderer.domElement.addEventListener(
          "click",
          function (event) {
            action = ACTION_SELECT;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          },
          false
        );

        rayCaster = new THREE.Raycaster();
        control = new TransformControls(camera, renderer.domElement);
        control.addEventListener("dragging-changed", function (event) {
          if (!event.value) {
            const points = curve.getPoints(50);
            line.geometry.setFromPoints(points);
            flow.updateCurve(0, curve);
          }
        });

        stats = new Stats();
        document.body.appendChild(stats.dom);

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        if (action === ACTION_SELECT) {
          rayCaster.setFromCamera(mouse, camera);
          action = ACTION_NONE;
          const intersects = rayCaster.intersectObjects(curveHandles);
          if (intersects.length) {
            const target = intersects[0].object;
            control.attach(target);
            scene.add(control);
          }
        }

        if (flow) {
          flow.moveAlongCurve(0.001);
        }

        render();
      }

      function render() {
        renderer.render(scene, camera);

        stats.update();
      }
    </script>
  </body>
</html>
